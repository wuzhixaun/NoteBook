# 一、二级缓存配置

## 简介

二级缓存构建在一级缓存之上，在收到查询请求时，MyBatis 首先会查询二级缓存，若二级缓存未命

中，再去查询一级缓存，一级缓存没有，再查询数据库。

``` mermaid
graph LR
	a(二级缓存) --> b(一级缓存) -->c(数据库)
```

与一级缓存不同，二级缓存和具体的命名空间绑定，一个Mapper中有一个Cache，相同Mapper中的 MappedStatement共用一个Cache，一级缓存则是和 SqlSession 绑定

## 如何启用二级缓存

### 1.开启全局二级缓存配置:

``` xml
 <settings>
   <setting name="cacheEnabled" value="true"/>
</settings>
```

### 2. 在需要使用二级缓存的Mapper配置文件中配置标签

``` XML
<cache></cache>
```

### 3.在具体CURD标签上配置 **useCache=true**

``` XML
 <select id="findById" resultType="com.wuzx.pojo.User" useCache="true">
    select * from user where id = #{id}
</select>
```

# 源码解析

## 标签 **< cache/>** 的解析

其实这这个标签是在每个mapper.xml文件配置的，所以每次都是解析mapper文件中一同解析的,来上源码

```
    // 解析 `<mapper />` 节点
    private void configurationElement(XNode context) {
        try {
            // 获得 namespace 属性
            String namespace = context.getStringAttribute("namespace");
            if (namespace == null || namespace.equals("")) {
                throw new BuilderException("Mapper's namespace cannot be empty");
            }
            // 设置 namespace 属性
            builderAssistant.setCurrentNamespace(namespace);
            // 解析 <cache-ref /> 节点
            cacheRefElement(context.evalNode("cache-ref"));
            // 解析 <cache /> 节点
            cacheElement(context.evalNode("cache"));
            // 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。
            parameterMapElement(context.evalNodes("/mapper/parameterMap"));
            // 解析 <resultMap /> 节点们
            resultMapElements(context.evalNodes("/mapper/resultMap"));
            // 解析 <sql /> 节点们
            sqlElement(context.evalNodes("/mapper/sql"));
            // 解析 <select /> <insert /> <update /> <delete /> 节点们
            // 这里会将生成的Cache包装到对应的MappedStatement
            buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
        } catch (Exception e) {
            throw new BuilderException("Error parsing Mapper XML. The XML location is '" + resource + "'. Cause: " + e, e);
        }
    }
    
        // 解析 <cache /> 标签
    private void cacheElement(XNode context) throws Exception {
        if (context != null) {
            //解析<cache/>标签的type属性，这里我们可以自定义cache的实现类，比如redisCache，如果没有自定义，这里使用和一级缓存相同的PERPETUAL
            String type = context.getStringAttribute("type", "PERPETUAL");
            Class<? extends Cache> typeClass = typeAliasRegistry.resolveAlias(type);
            // 获得负责过期的 Cache 实现类
            String eviction = context.getStringAttribute("eviction", "LRU");
            Class<? extends Cache> evictionClass = typeAliasRegistry.resolveAlias(eviction);
            // 清空缓存的频率。0 代表不清空
            Long flushInterval = context.getLongAttribute("flushInterval");
            // 缓存容器大小
            Integer size = context.getIntAttribute("size");
            // 是否序列化
            boolean readWrite = !context.getBooleanAttribute("readOnly", false);
            // 是否阻塞
            boolean blocking = context.getBooleanAttribute("blocking", false);
            // 获得 Properties 属性
            Properties props = context.getChildrenAsProperties();
            // 创建 Cache 对象
            builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
        }
    }
    
    
       /**
     * 创建 Cache 对象
     *
     * @param typeClass 负责存储的 Cache 实现类
     * @param evictionClass 负责过期的 Cache 实现类
     * @param flushInterval 清空缓存的频率。0 代表不清空
     * @param size 缓存容器大小
     * @param readWrite 是否序列化
     * @param blocking 是否阻塞
     * @param props Properties 对象
     * @return Cache 对象
     */
    public Cache useNewCache(Class<? extends Cache> typeClass,
                             Class<? extends Cache> evictionClass,
                             Long flushInterval,
                             Integer size,
                             boolean readWrite,
                             boolean blocking,
                             Properties props) {

        // 1.生成Cache对象
        Cache cache = new CacheBuilder(currentNamespace)
                //这里如果我们定义了<cache/>中的type，就使用自定义的Cache,否则使用和一级缓存相同的PerpetualCache
                .implementation(valueOrDefault(typeClass, PerpetualCache.class))
                .addDecorator(valueOrDefault(evictionClass, LruCache.class))
                .clearInterval(flushInterval)
                .size(size)
                .readWrite(readWrite)
                .blocking(blocking)
                .properties(props)
                .build();
        // 2.添加到Configuration中
        configuration.addCache(cache);
        // 3.并将cache赋值给MapperBuilderAssistant.currentCache
        currentCache = cache;
        return cache;
    }
```

看源码可以得出，其实 id就是namespace标签配置的只，然后这个cache对象会加入到configuration对象的cachaes集合里面，将cache赋值给MapperBuilderAssistant.currentCache

``` java
    /**
     * Cache 对象集合
     *
     * KEY：命名空间 namespace
     */
    protected final Map<String, Cache> caches = new StrictMap<>("Caches collection");
```

# 二、查询调用缓存源码剖析

## CachingExecutor（支持二级缓存的 Executor 的实现类）

``` java
    public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
        // 获得 BoundSql 对象
        BoundSql boundSql = ms.getBoundSql(parameterObject);
        // 创建 CacheKey 对象
        CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
        // 查询
        return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }

    public Object getObject(Object key) {
        // 查询的时候是直接从delegate中去查询的，也就是从真正的缓存对象中查询
        Object object = delegate.getObject(key);
        // 如果不存在，则添加到 entriesMissedInCache 中
        if (object == null) {
            // 缓存未命中，则将 key 存入到 entriesMissedInCache 中
            entriesMissedInCache.add(key);
        }
        // issue #146
        // 如果 clearOnCommit 为 true ，表示处于持续清空状态，则返回 null
        if (clearOnCommit) {
            return null;
        // 返回 value
        } else {
            return object;
        }
    }

    public void putObject(Object key, Object object) {
        // 将键值对存入到 entriesToAddOnCommit 这个Map中中，而非真实的缓存对象 delegate 中
        entriesToAddOnCommit.put(key, object);
    }	
```

存储二级缓存对象的时候是放到了TransactionalCache.entriesToAddOnCommit这个map中，但是每 次查询的时候是直接从TransactionalCache.delegate中去查询的，所以这个二级缓存查询数据库后，设 置缓存值是没有立刻生效的，主要是因为直接存到 delegate 会导致脏数据问题

## 三、为何只有**SqlSession**提交或关闭之后? 

那我们来看下SqlSession.commit()方法做了什么

### **SqlSession**

``` java
    public void commit(boolean force) {
        try {
            // 提交事务
            executor.commit(isCommitOrRollbackRequired(force));
            // 标记 dirty 为 false
            dirty = false;
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error committing transaction.  Cause: " + e, e);
        } finally {
            ErrorContext.instance().reset();
        }
    }
    public void commit(boolean required) throws SQLException {
        // 执行 delegate 对应的方法
        delegate.commit(required);
        // 提交 TransactionalCacheManager
        tcm.commit();
    }
    /**
     * 提交所有 TransactionalCache
     */
    public void commit() {
        for (TransactionalCache txCache : transactionalCaches.values()) {
            txCache.commit();
        }
    }

```



## 二级缓存的刷新



``` java
    public int update(MappedStatement ms, Object parameterObject) throws SQLException {
        // 如果需要清空缓存，则进行清空
        flushCacheIfRequired(ms);
        // 执行 delegate 对应的方法
        return delegate.update(ms, parameterObject);
    }

    /**
     * 如果需要清空缓存，则进行清空
     *
     * @param ms MappedStatement 对象
     */
    private void flushCacheIfRequired(MappedStatement ms) {
        Cache cache = ms.getCache();
        if (cache != null && ms.isFlushCacheRequired()) { // 是否需要清空缓存
            tcm.clear(cache);
        }
    }
```

MyBatis二级缓存只适用于不常进行增、删、改的数据，比如国家行政区省市区街道数据。一但数据变 更，MyBatis会清空缓存。因此二级缓存不适用于经常进行更新的数据。


# 四、总结

在二级缓存的设计上，MyBatis大量地运用了装饰者模式，如CachingExecutor, 以及各种Cache接口的 装饰器

+ 二级缓存实现了Sqlsession之间的缓存数据共享，属于namespace级别 
+ 二级缓存具有丰富的缓存策略。
+  二级缓存可由多个装饰器，与基础缓存组合而成
+  二级缓存工作由 一个缓存装饰执行器CachingExecutor和 一个事务型预缓存TransactionalCache 完成。
