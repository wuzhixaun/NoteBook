# 1. **描述一下jvm内存模型，以及这些空间的存放的内容 ?**

> 1. `java stack 虚拟机栈`：栈帧，所有的局部变量都在这里创建
> 2. `native method stack本地方法栈`：执行非java代码，执行c、C++ 的代码
> 3. `Program count register程序计数器`:指向字节码执行的行号
> 4. 方法区
> 5. 堆
> 6. 执行引擎：执行字节码，对字节码进行优化，然后执行GC

https://processon.com/diagraming/62bfcd060e3e74659206bd4a

#  2. **堆内存划分的空间，如何回收这些内存对象，有哪些回收算法?**

> ![image-20220703131150442](https://cdn.wuzx.cool/image-20220703131150442.png)

```
垃圾回收算法:标记清除、复制(多为新生代垃圾回收使用)、标记整理
```

## **为什么分年老代和新生代**

+ `新生代(Young Gen)`：年轻代主要存放新创建的对象，[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（from 和to）。
+ `老年代(Tenured Gen)`：年老代主要存放[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁。

`新生代`:对象朝生夕死，垃圾特别多，新生代留下来的对象也很少，对他进行整理，所以适用的算法标记清除、复制(多为新生代垃圾回收使用), 

`老年代`:对象存活比较久，这个时候可以使用标记清除算法

## 新生代为什么又分Eden、Survivor Space

+ 如果没有Survivor区，那么Eden每进行一次minor GC都会将存活的对象送到老年代，老年代将很快会填满。触发Major GC 老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor
+ Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
+ 设置两个Survivor区最大的好处就是解决了碎片化.
+ 刚刚新建的对象在Eden中，经历一次Minor
  GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满
  了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space
  S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续
  的内存空间，避免了碎片化的发生）。

## 为什么JDK1.8干掉永久代

+ 由于原来永久代分配在堆中容易出现性能问题和内存溢出。
+ 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太 大则容易导致老年代溢出。
+ 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

# 3. 如何解决线上GC频繁的问题

![image-20220703134933382](https://cdn.wuzx.cool/image-20220703134933382.png)

> 1. 查看监控、了解出现问题的时间点以及当前FGC的频率(可对比正常情况下的频率是否正常)
> 2. 了解该时间点有没有程序上线，基础组件的升级等等
> 3. 了解JVM的参数设置，包括堆空间以及各个区域的大小设置，新生代，老年代各使用了哪些垃圾收集器，然后分析JVM的参数是否设计合理
> 4. 在对照各个原因做排除法，其中元空间被打满、内存泄漏、代码显示调用system.gc方法比较容易排查
> 5. 针对大对象或者长生命周期对象导致FGC，可以通过jmap - histo 命令结合dump堆内存文件作进一步分析，去定位哪个对象是可疑的()
> 6. 然后通过可疑的对象具体定位到代码在进行分析，这个时候结合GC原理和JVM参数设置，弄清楚可疑对象是否满足进入老年代的条件

# 4. 描述一下class初始化的过程

![image-20220704000633341](https://cdn.wuzx.cool/image-20220704000633341.png)

# 5. 简述一下内存溢出的原因，如何排查线上问题

+ `内存溢出`：在申请内存时，没有足够的内存空间供其使用，出现out of memory
  + 解决方案
    + 修改JVM启动参数，增加内存。比如 -Xms 参数用来指定初始堆的大小（s 表示 start）。-Xmx 参数用来指定最大堆的大小（x 表示 max），适当增加这两参数的大小
    + 

+ `内存泄漏`： 是指无法释放已申请的内存空间，导致无用对象持续占有内存，从而造成内存空间的浪费。例如你创建了一个list里面放了很多东西，但是从来没有使用他
  + 解决方案
    + 及时释放无用对象的引用，比如及时将不用的变量设置为null，暗示GC回收它
    + 少用静态变量，因为静态变量是全局的，生命周期和应用程序的一样长。

> + Java.lang.OutOfMemoryError: ... java heap space...堆栈溢出，代码问题可能很大
> + Java.lang.OutOfMemoryError: GC over head limit exceeded 系统处于高频的GC状态，而且回收的效果依然不佳，就会报这个错误，这种情况之下一般是产生了很多不可以被释放的对象。有可能是引用不当，或者申请大对像导致。但是java heap space 的内存溢出
> + Java.lang.OutOfMemoryError:  PermGen space jdk1.7之前才会出现这个问题，原因是系统代码非常多，或者引用了第三方的包非常多、代码使用了大量的常量、或者通过intern注入的常量非常多或者通过动态代码记载等方法，导致常量池的膨胀
> + Java.lang.OutOfMemoryError: Direct buffer memory 直接内存不足，因为jvm垃圾回收不会回收直接内存这部分的内存，所以可能原因直接或者间接使用了ByteBuffer中的allocatDirect方法，没有clear
> + Java.lang.StackOverflowError: - Xss 栈的内存设置太小了
> + Java.lang.OutOfMemoryError: unable to create new native thread 堆外内存不足，无法为线程分配内存区域
> + Java.lang.OutOfMemoryError: request {} byte for {} out of sawp 地址空间不够

# 6.JVM有哪些垃圾回收期，实际中该如何选择

![image-20220704003711822](https://cdn.wuzx.cool/image-20220704003711822.png)

+ 并行： 多个垃圾收集线程并行工作，此时用户线程处于等待状态

+ 并发：用户线程和垃圾收集线程同时执行
+ 吞吐量：运行用户代码时间/(运行用户代码时间+ 垃圾回收时间)

## 6.1 Serial

> Serial收集器最基本，发展历史最悠久的线程

### 特点

> 单线程，简单高效(与其他收集器的单线程相比)，对于单个CPU的环境，Serial收集器由于没有线程交互的的开销，专心做垃圾收集自然可以获得最高的单线程回收效率。收集器进行垃圾收集时，必须暂停其他所有的工作线程，直到它结束（Stop the World）

### 适用场景

![image-20220704010312485](https://cdn.wuzx.cool/image-20220704010312485.png)

## 6.2 ParNew 

> ParNew 其实就是Serial 收集器的多线程版本，除了适用多线程外，其余的行为和Serial一模一样(参数控制，收集算法，Stop the World ，对象分配规则，回收策略)

### 特点

> 多线程，ParNew收集器默认开启的是与CPU数量相同，在CPU非常多的环境中，可以适用 -XX:ParallelGCThread参数来限制垃圾收集器的线程数

### 适用场景

> 可以和CMS(标记清除)配合

![image-20220704011355163](https://cdn.wuzx.cool/image-20220704011355163.png)

## 6.3 Parallel Scavenge

> Parallel Scavenge 收集器与吞吐量关系密切，故也称为吞吐量优先收集器

### 特点

> 属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器(与ParNew收集器类似)
>
> 该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是:GC自适应调节策略

### **GC自适应调节策略**

> 可设置-XX:+UseAdptiveSizePolicy参数 当开关打开时不 需要手动指定新生代的大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRation)、晋升老年代 的对象年龄(-XX:PretenureSizeThreshold)等，虚拟机会根据系统的运行状况收集性能监控信息，动 态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略

### Parallel Scavenge收集器使用两个参数控制吞吐量:

+ XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
+ XX:GCRatio 直接设置吞吐量的大小。

## 6.4 Serial Old

> Serial Old是Serial收集器的老年代版本

### 特点

> :同样是单线程收集器，采用标记-整理算法。

### **应用场景**

> 1. 在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。
> 2. 作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。

![image-20220704011949798](https://cdn.wuzx.cool/image-20220704011949798.png)

## 6.5 Parallel Old

> Parallel Old是Parallel Scavenge收集器的老年代版本

### 特点

> 多线程，采用标记-整理算法。

### **应用场景**

> 注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收 集器。

![image-20220704012307496](https://cdn.wuzx.cool/image-20220704012307496.png)

## 6.6 CMS

> CMS收集器是一种以获取最短回收停顿时间为目标的收集器

### 特点

>基于标记-清除算法实现。并发收集、低停顿。

### **应用场景**

> 适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web程序、b/s服务

### CMS收集器的运行过程分为下列4步

+ **初始标记**:标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。
+ **并发标记**:进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。
+ **重新标记**:为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记 录。仍然存在Stop The World问题。
+ **并发清除**:对标记的对象进行清除回收。

![image-20220704012727394](https://cdn.wuzx.cool/image-20220704012727394.png)

## 6.7 G1收集器

> G1收集器一款面向服务端应用的垃圾收集器

### 特点

> + 并行与并发:G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿 时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序 继续运行。
>
> + 分代收集:G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时 间、熬过多次GC的旧对象以获取更好的收集效果。
>
> + 空间整合:G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。
>
> + 可预测的停顿:G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长
>
>   度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

### **G1收集器运行示意图:**

![image-20220704013004853](https://cdn.wuzx.cool/image-20220704013004853.png)

## 关于gc的选择

除非应用程序有非常严格的暂停时间要求，否则请先运行应用程序并允许VM选择收集器(如果没有特别 要求。使用VM提供给的默认GC就好)。
 如有必要，调整堆大小以提高性能。 如果性能仍然不能满足目标，请使用以下准则作为选择收集器的起 点:

+ 如果应用程序的数据集较小(最大约100 MB)，则选择带有选项-XX:+ UseSerialGC的串行 收集器。
+ 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项-XX:+ UseSerialGC的串行收集器。
+ 如果(a)峰值应用程序性能是第一要务，并且(b)没有暂停时间要求或可接受一秒或更长 时间的暂停，则让VM选择收集器或使用-XX:+ UseParallelGC选择并行收集器 。
+ 如果响应时间比整体吞吐量更重要，并且垃圾收集暂停时间必须保持在大约一秒钟以内，则选 择具有-XX:+ UseG1GC。(值得注意的是JDK9中CMS已经被Deprecated，不可使用!移除 该选项)
+ 如果使用的是jdk8，并且堆内存达到了16G，那么推荐使用G1收集器，来控制每次垃圾收集 的时间。

# 7.简述一下Java类加载模型?

![image-20220704013614579](https://cdn.wuzx.cool/image-20220704013614579.png)

### 双亲委派模型

> 在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器 (Bootstrap)。如果顶层加载不了(它的搜索范围中找不到此类)，子加载器才会尝试加载这个类。 双亲委派的好处
>
> + 每一个类都只会被加载一次，避免了重复加载
> + 每一个类都会被尽可能的加载(从引导类加载器往下，每个加载器都可能会根据优先次序尝试加载它
> + 有效避免了某些恶意类的加载(比如自定义了Java.lang.Object类，一般而言在双亲委派模型 下会加载系统的Object类而不是自定义的Object类)

## 为什么要使用双亲委派机制

+ 安全机制:例如我们自己写的String(java.lang.String.class)类不会被加载，这样防止核心类库被篡改
+ 避免类的重复加载，当父类加载器已经加载了这个类，子类加载器没必要在加载一遍，保证被加载类的唯一性

## 自定义类加载器 

> 重写findCLass(name) 方法

## 打破双亲委派机

> ``` java
> loadClass(String name, boolean resolve) {
>   
>   try{
>     Class<?> c = findLoadedClass(name);
>     
>     if(c== null ){
>       if(parent != null){
>         // 使用父类加载器
>          c = parent.loadClass(name, false);
>       }else{ 
>         // 使用引导类加载器
>         c = findBootstrapClassOrNull(name);
>       }
>      
>     }
>     
>     if(c == null){
>       c = findClass(name);
>     }
>   }  
> }
> ```
>
> 所以打破双亲委派机制就是 重写loadClass方法

# 8. **JVM8**为什么要增加元空间，带来什么好处?

> + 字符串存在永久代中，容易出现性能问题和内存溢出。
> + 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢 出，太大则容易导致老年代溢出。
> + 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
> + 元空间的特点:
>    1，每个加载器有专门的存储空间。
>    2，不会单独回收某个类。
>    3，元空间里的对象的位置是固定的。
>    4，如果发现某个加载器不再存货了，会把相关的空间整个回收。

# 9.**10.** 堆G1垃圾收集器有了解么，有什么特点(可以结合第6题内 容)

> G1的特点:
>
> + G1的设计原则是"首先收集尽可能多的垃圾(Garbage First)"。因此，G1并不会等内存耗尽(串 行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找 出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻 代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大
> + G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分 区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位 进行操作，因此G1天然就是一种压缩方案(局部压缩);
> + G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要 完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都 可能随G1的运行在不同代之间前后切换
> + G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方 式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部 分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。
> + 因为G1建立可预测的停顿时间模型，所以每一次的垃圾回收时间都可控，那么对于大堆 (16G左右)的垃圾收集会有明显优势

# 10 .**介绍一下垃圾回收算法?**

![image-20220704014433181](https://cdn.wuzx.cool/image-20220704014433181.png)

![image-20220704014441358](https://cdn.wuzx.cool/image-20220704014441358.png)

# 11.Happens-Before规则?

先行发生原则(Happens-Before)是判断数据是否存在竞争、线程是否安全的主要依据。 先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么**操作** **A****产生的影响能够被操作****B****观察到**。 口诀:如果两个操作之间具有happen-before关系，**那么前一个操作的结果就会对后面的一个操作可 见**。**是****Java****内存模型中定义的两个操作之间的偏序关系**。

**常见的**happen-before**规则:
** **1.****程序顺序规则:** 一个线程中的每个操作，happen-before在该线程中的任意后续操作。(注解:如果只有一个线程的操 作，那么前一个操作的结果肯定会对后续的操作可见。) 程序顺序规则中所说的每个操作happen-before于该线程中的任意后续操作并不是说前一个操作必须要 在后一个操作之前执行，而是指前一个操作的执行结果必须对后一个操作可见，如果不满足这个要求那就不允许这两个操作进行重排序

**2.****锁规则:** 对一个锁的解锁，happen-before在随后对这个锁加锁。(注解:这个最常见的就是synchronized方法和 syncronized块)
 **3.volatile****变量规则:** 对一个volatile域的写，happen-before在任意后续对这个volatile域的读。该规则在CurrentHashMap 的读操作中不需要加锁有很好的体现。
 **4.****传递性:
** 如果A happen-before B，且B happen-before C，那么A happen - before C.
 **5.****线程启动规则:
** Thread对象的start()方法happen-before此线程的每一个动作。
 **6.****线程终止规则:** 线程的所有操作都happen-before对此线程的终止检测，可以通过Thread.join()方法结束， Thread.isAlive()的返回值等手段检测到线程已经终止执行。
 **7.****线程中断规则:** 对线程interrupt()方法的调用happen-before发生于被中断线程的代码检测到中断时事件的发生。

# 12. **描述一下**java类加载和初始化的过程?

**JAVA****类的加载机制**

Java类加载分为5个过程,分别为:加载，链接(验证，准备，解析)，初始化，使用，卸载。

1 加载
 加载主要是将.class文件通过二进制字节流读入到JVM中。 在加载阶段，JVM需要完成3件事: 

+ 1)通过classloader在classpath中获取XXX.class文件，将其以二进制流的形式读入内存。 
+ 2)将字节流所代表的静态存储结构转化为方法区的运行时数据结构;
+  3)在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

2 链接

+ 验证: 主要确保加载进来的字节流符合JVM规范。验证阶段会完成以下4个阶段的检验动作: 

  + 1)文件格式验证\

  + 2)元数据验证(是否符合Java语言规范) 

  + 3)字节码验证(确定程序语义合法，符合逻辑) 

  + 4)符号引用验证(确保下一步的解析能正常执行)

+ 准备 准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值。

+ 解析 解析是连接阶段的第三步，是虚拟机将常量池内的符号引用替换为直接引用的过程。

3 初始化 初始化阶段是类加载过程的最后一步，主要是根据程序中的赋值语句主动为类变量赋值。 当有继承关系时，先初始化父类再初始化子类，所以创建一个子类时其实内存中存在两个对象实 例。

4 使用 程序之间的相互调用。

5 卸载 即销毁一个对象，一般情况下中有JVM垃圾回收器完成。代码层面的销毁只是将引用置为null。



# 13. **吞吐量优先和响应时间优先的回收器是哪些?**

> + 吞吐量优先:Parallel Scavenge+Parallel Old(多线程并行) 
> + 响应时间优先:cms+par new(并发回收垃圾)

# 14. **什么叫做阻塞队列的有界和无界，实际中有用过吗**

+ ArrayBlockingQueue:一个由**数组**结构组成的**有界**阻塞队列，线程池，生产者消费者 
+ LinkedBlockingQueue:一个由**链表**结构组成的**无界**阻塞队列，线程池，生产者消费者 
+ PriorityBlockingQueue:一个**支持优先级排序**的**无界**阻塞队列，可以实现精确的定时任务 
+ DelayQueue:一个**使用优先级队列**实现的**无界**阻塞队列，可以实现精确的定时任务 
+ SynchronousQueue:一个不存储元素的阻塞队列，线程池 (容量等于0的同步队列)
+ LinkedTransferQueue:一个由**链表**结构组成的**无界**阻塞队列 
+ LinkedBlockingDeque:一个由**链表**结构组成的**双向无界**阻塞队列，可以用在“工作窃取”模式 中

### ArrayBlockingQueue 和 LinkedBlockingQueue区别

> ArrayBlockingQueue 是一把锁
>
> LinkedBlockingQueue 是两把锁 一把take锁，一把是put锁，所以并发上去了

### 什么ArrayBlockingQueue，LinkedBlockingQueue怎么选择

> cpu缓存行

### PriorityBlockingQueue排序的基础 

> 实现com

### SynchronousQueue怎么玩的

> 我不会

# 15.  **jvm**监控系统是通过jmx做的么?

是的

# 16.  **内存屏障的汇编指令是啥?**

> 1.硬件内存屏障 X86
>  sfence: store| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成。
>  lfence:load | 在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 mfence:modify/mix | 在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。 2.原子指令，如x86上的”lock ...” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚 至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序。 3.JVM级别如何规范(JSR133)
>  LoadLoad屏障:
>  对于这样的语句Load1; LoadLoad; Load2， 在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障:
>  对于这样的语句Store1; StoreStore; Store2， 在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
>  LoadStore屏障:
>  对于这样的语句Load1; LoadStore; Store2， 在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
>  StoreLoad屏障:
>  对于这样的语句Store1; StoreLoad; Load2， 在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。