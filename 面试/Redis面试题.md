# 1. 说说你在项目中的redis的应用场景

> Redis支持五大数据类型，分别是String、List、Set、Hash、ZSet。

## 1.1 缓存

> String类型
>
> 例如：热点数据缓存、对象缓存、全页缓存、可以提升热点数据的访问数据。

## 1.2 **数据共享分布式**

> String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享
>
> 例如：分布式Session

## 1.3 **分布式锁**

> String 类型setnx方法，只有不存在时才能添加成功，返回true
>
> ``` java
> public static boolean getLock(String key) {
>     Long flag = jedis.setnx(key, "1");
>     if (flag == 1) {
>         jedis.expire(key, 10); // 避免死锁
>     }
>     return flag == 1;
> }
> 
> public static void releaseLock(String key) {
>     jedis.del(key);
> }
> ```

## 1.4 全局ID

> int类型，incrby，利用原子性
>
> incrby userid 1000
>
> 分库分表的场景，一次性拿一段

## 1.5 计数器

> int类型，incr方法
>
> 文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库

## 1.6 限流

> int类型，incr方法
>
> 以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false	

# 2. Set、Zset分别用于哪些场景

+ set
  + . 标签:给用户打上感兴趣的标签，然后就能知道相同不同用户拥有相互爱好的群体；
  + 公共好友: 一个人的好友，这样的话就能知道共同拥有的好友；
+ Zset 
  + 根据时间排序的新闻列表等，成绩
  +  [阅读](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttp%3A%2F%2Fbook.2cto.com%2F)排行榜

# 3. redis是单线程还是多线程

+ 无论什么版本 `工作线程`就是一个
+ 6.x出现了IO多线程
+ 单线程, 满足redis的串行原子。只不过IO多线程后，把输入/输出放到更多的线程里去并行好处如下
  + 执行时间缩短、更快
  + 更好的利用系统以及系统资源

# 4. redis 存在线程安全的问题吗？为什么

单线程串行，redis可以保障内部串行，但是在业务使用上面要自行保障顺序

# 5.遇到过缓存穿透吗？

`穿透`： 没有这笔数据

+ 设置 null key
+ 布隆过滤器

如果是多个请求一起过来，已经到达的需求已经在串行里， 根据上面的方案，还是会在这个时候查询数据库

这个时候设置一个锁，多个请求去抢一个锁

# 6.遇到过缓存击穿吗？

`击穿`: 热点key 过期(从来没有被缓存的) 数据库有，大量的并发，redis没有缓存

并发的问题就是要使用锁

+ 请求redis，看是否有
+ 所有的请求进行抢锁
  + 抢到的查询Db O(1)
  + 没有抢到的sleep
+ 获取Db数据更新redis
+ sleep回到第一步 

# 7.如何避免缓存雪崩

缓存集中在一段时间内失效，引发大量缓存穿透，所有的查询都落在数据库上，造成[缓存雪崩](https://so.csdn.net/so/search?q=缓存雪崩&spm=1001.2101.3001.7020)，由于原有缓存失效，新缓存未到期间所有原本访问缓存的都去访问了数据库，而对数据库cpu和内存造成巨大压力，从而引发宕机

2.1 加锁排队

mutex互斥锁解决，Redis的setnx去set一个mutex key,当操作返回成功时，再进行load db并回设到缓存，否则就重试整个get缓存的方法。

2.2 数据预热

数据预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候先查询数据库。

2.3 双层缓存策略

C1为原始缓存，C2为拷贝缓存，C1失效时可以访问C2，C1缓存失效时间设置为短期，C2缓存失效时间设置为长期。

2.4 定时更新缓存策略

失效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存。

2.5 缓存失效时间分布均匀

设置不同的过期时间，让缓存失效的时间尽量分布均匀。

# 8.缓存如何回收的

> + 后台轮询，分段分批的删除过期的key
> + 请求的时候判断是否已经过期

# 9.redis是怎么删除过期的key



# 10.缓存如何淘汰的

内存空间不足的情况下，会进行淘汰

+ lru/lfu/random
+ 全空间
+ 设置过 过期的集合中

# 9.如何进行缓存预热

> + 开发逻辑上面也要规避差集，会造成击穿，穿透，雪崩
>
> + 解决方案
>
>   1）直接写个缓存刷新页面，上线时手工操作下。
>   2）数据量不大，可以在项目启动的时候自动进行加载。
>   3）定时刷新缓存。

# 10.数据库与缓存不一致如何解决

## 10.1 **先删除缓存，再更新数据库**

![image-20220702112154873](https://cdn.wuzx.cool/image-20220702112154873.png)

> 假设线程A删除缓存的值后，还没有来得及更新数据库(比如说网络延迟)，线程B开始读取数据，这个时候B会发现缓存缺失，就只能去数据库中读取，这会带来两个问题
>
> + 线程B读取到数据库中的旧值
> + 线程B在缓存缺失的情况下读取数据库，然后将旧值放入缓存，其他的线程也会读取到旧值。此时线程A更新完数据库的值。造成了缓存与数据库不一致

### 解决方案：延迟双删，A线程先删除数据库的数据，**线程A更新完数据库值以后**,**先sleep一小段时间，再进行一次缓存删除操作**（这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。）

## 10.2 **先更新数据库值，再删除缓存值。**

![image-20220702114040929](https://cdn.wuzx.cool/image-20220702114040929.png)

> 解决方案:
>
> - 删除缓存值或更新数据库失败而导致数据不一致，你可以使用重试机制确保删除或更新操作成功。
> - 在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作，导致其他线程读取到旧值，应对方案是延迟双删

![image-20220702114218297](https://cdn.wuzx.cool/image-20220702114218297.png)

### 10.3 使用 Binlog 和 Canal 从 MySQL 抽取数据

Canal 会将自己伪装成 MySQL 从节点（Slave），并从主节点（Master）获取 Binlog，解析和贮存后供下游消费端使用

# 11.简述一下主从不一致的问题

> Redis 的确是弱一致性，异步的同步
>
> Redis 锁不能用主从（单实例、分片集群、redlock）
>
> 在配置中提供必须多少个Client连接可以同步，你可以配置同步因子，趋于强一致性

# 12.Redis有哪些持久化方法

+ RDB:是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
+ AOF:以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。
+ 主从同步

> AOF：

# 13.Redis也打不住了，万级流量打到DB上，该怎么处理

456

# 14. 描述一下redis持久化原理

当前线程阻塞服务

异步后台进程完成持久化

Fork + cow

# 15.为什么使用setNx

原子性

set if not exist
当某个key不存在的时候创建这个key并设置value，当它存在的话就不进行操作。
set if exist
当某个key存在的时候才会设置成功。

# 16redis实现分布式锁的指令

# 17 redis事务的三条指令是什么，第三条指令到达后执行失败了，怎么处理
