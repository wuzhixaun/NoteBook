# 1.TCP三次握手哦

> + **第一次握手：**客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认;
> + **第二次握手：**服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(seq=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;
> + **第三次握手：**客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

# 2. TCP四次挥手

> **第一次挥手：**主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当 然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据。
>
> **第二次挥手：**被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)。
>
> **第三次挥手：**被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
>
> **第四次挥手：**主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手

# 3.TCP连接状态

 ![image-20220716012329876](https://cdn.wuzx.cool/image-20220716012329876.png)

客户端tcp状态迁移

CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED

服务器TCP状态迁移：

CLOSED->LISTEN->SYN收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED

LISTEN：侦听来自远方TCP端口的连接请求

SYN-SENT：发送连接请求后等待匹配的连接请求

SYN-RECEIVED（syn已经收到的）：收到和发送给一个连接请求后等待对连接请求的确认

ESTABLISHED(已建立的)：代表一个打开的连接，数据可以传送给客户

FIN-WAIT-1：等待远程TCP的连接中断请求，或者先前的连接中断请求的确认

FIN-WAIT-2：从远程TCP等待连接中断请求

CLOSE-WAIT：等待从本地用户发来的连接中断请求

CLOSEING：等待远程TCP对连接中断的确认

LAST-ACK：等待原来发向远程TCP的连接中断请求的确认

TIME-WAIT：等待足够的时间一确保远程TCP接受到连接中断请求的确认

CLOSED：没有任何连接状态

# 4.Connection refused

![image-20220716012600217](https://cdn.wuzx.cool/image-20220716012600217.png)

# 5.OSI七层



# 6.什么是长连接和短链接

TCP 可长可短，tcp只是连接，受应用层协议来控制

连接是不是复用载体来区分是否长短 keepLIve保持，一个连接负责同步阻塞请求+响应，这个是短连接

开启了 keepLIve，同步复用连接，可以多次请求+响应

# 7.IO模型

IO是程序对着内核socket-queue的包装

BIO :读取一只等queue有才返回，阻塞模型，每连接对应一个线程

NIO：读取，立刻返回.两种结果，读到，没有读到，程序逻辑自己维护

多路复用器: 

# 8.同步阻塞，同步非阻塞



# 9.有状态，无状态



# 10.粘包、拆包



**【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？**答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，'你发的FIN报文我收到了'。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。