# 一、分布式锁(可以写入项目中)

## 1.1 Setnx key value expire time

```  shell
setnx key value ex 10 
// 必须设置过期时间,不然如果服务过了，其他的将永远获取不到锁
```

+ setnx key value ex 10 `·必须原子操作`·，如果拆分，当key设置成功，然后执行expire 的时候，redis宕机，可能过期时间没有设置，所以就会一只造成死锁

+ 如果事务还没有处理完，锁过期了，那么别人是可以获取到锁的，然后你会进行删除别人的锁的操作
  
  + 就是生成一个uuid,value设置这个uuid,然后哦，最后面删除key的时候判断 uuid 是相同的才删除(这样还是会有问题不推荐这么做)
  
    ``` java
    if (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))) {
      stringRedisTemplate.delete(lockKey);
    }
    ```
  
    
  
  + 起一个线程续期，使得锁不会过期
  
    + 使用Redission
  
      原理![Redisson分布式锁原理](https://cdn.wuzx.cool/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png)
  
      ``` java
        //获取锁对象
              RLock redissonLock = redisson.getLock(lockKey);
              //加分布式锁
              redissonLock.lock();  //  .setIfAbsent(lockKey, clientId, 30, TimeUnit.SECONDS);
              try {
                      System.out.println("扣减失败，库存不足");
              } finally {
                  //解锁
                  redissonLock.unlock();
              }
      ```
  

## 1.2 分段锁

key : product:100_1 100

![image-20220714012041496](https://cdn.wuzx.cool/image-20220714012041496.png)

> 主从集群问题 ，服务A获取到锁，master 挂了，此时数据还没有同步到slave节点，然后服务A1进行枷锁，还是可以获得锁
>
> ![image-20220714012918498](https://cdn.wuzx.cool/image-20220714012918498.png)
>
> ## 解决方法：红锁
>
> + 准备5台没有关系的redis服务，全是主
> + 先在1加锁，2加锁，3加锁，过半就是加锁成功
> + 然后服务A2准备加锁，1,2,3加锁失败，只能4,5加锁成功，但是没有过半，加锁失败

## 红锁的缺点，如果中间redis重启，数据丢失，所以其他的线程可以加锁	（延迟启动24h）

![image-20220714014010000](https://cdn.wuzx.cool/image-20220714014010000.png)

## gc （stop the world ,续期线程没有执行,所以两个线程都获取到了锁）

> 鸵鸟算法









# 2.分布式事务

![image-20220714233914814](https://cdn.wuzx.cool/image-20220714233914814.png)

## 方式一：两阶段提交协议

该协议将一个分布式的事务过程拆分成两个阶段： **投票** 和 **事务提交** 。为了让整个数据库集群能够正常的运行，该协议指定了一个 **协调者** 单点，用于协调整个数据库集群各节点的运行。为了简化描述，我们将数据库集群中的各个节点称为 **参与者**

### 一阶段：投票

打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下：

> + 协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果
> + 参与者收到请求后，执行事务但是并不提交，记录事务日志
> + 参与者将自己直接结果反馈者协调者

### 二阶段： 提交

在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在 3 种可能性：

+ 所有参与者都回复可以执行事务成功
+ 一个或者多个参与者回复执行失败
+ 协调者等待超时

#### 情况1 所有的参与者都回复能够正常执行事务,于是协调者让他们都提交事务

![image-20220714234924238](https://cdn.wuzx.cool/image-20220714234924238.png)

#### 情况2  一个或者多个参与者回复执行失败，做回滚处理，或者手动补偿

![image-20220714235238446](https://cdn.wuzx.cool/image-20220714235238446.png)

> 如何手动补偿，加入订单服务，下了一个订单，然后有一个积分服务，但是没有看到积分的增加，我们启动定时任务查询订单服务有数据，而积分没有数据的，手动增加一条

### 缺点

+ 单点故障，协调者挂了，那么这个就挂了
+ 占用资源：第一阶段执行sql，没有提交这个时候一直占着连接池资源，
+ 数据不一致，协调者发出的事务 commit 通知有可能因为网络原因无法传递到部分参与者，造成它们一直处于阻塞状态，导致数据不一致

SEATA 的AT 模式就是两个阶段(https://www.jianshu.com/p/69f75ba8b4c8?u_atoken=077192af-60cd-41ed-a957-8bceef3ada17&u_asession=01mqn5IGAYYSrrCg7vCRkkH27YT_EC7HknSe0D22QD-nFuzgygkTLUqaDB5cHywXSyX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K8v-HV5FVoqZH908RrRgrRDyuYfe7vWV-zsHJifFo5DumBkFo3NEHBv0PZUm6pbxQU&u_asig=05AuiogwoKKcxKt5qAOOwfnhqn2l6Lanx0rmfPGheXSW951kz3L0aC4OfX1vc_6YH9K8Xlxn6qV3YQSKqlW9GHLTA8sWGbECSbvNRWNEPbyw6MNtdJcpg-OzzrOVh1597x6T803MLNm7D1RBVcjluE9kYE8EzYJT-n5NDynQxjuAX9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzTuYADrKruPYb4QK_VtY_hY8bGklrXjZtF1cuSdhIIX1fqft3yiexPr1Pj5ASov3mu3h9VXwMyh6PgyDIVSG1W8SGQvE3Ae41dDnukEac2lR2anoXy5jXgsUqSf53wA3-7V7XajcvZepx4sdoLHWKH3YA1zl0EXrt3sTZnBra6LdmWspDxyAEEo4kbsryBKb9Q&u_aref=9RyJXF5Nhvn7%2F2OdmF8zsaUyOJI%3D)

## 方式二: 三阶段

![image-20220715001651998](https://cdn.wuzx.cool/image-20220715001651998.png)

### can commit

>  协调者向参与者发送[commit](https://so.csdn.net/so/search?q=commit&spm=1001.2101.3001.7020)请求，参与者如果可以提交就返回yes响应，否则返回no响应

### Pre commit

> 协调者根据参与者canCommit阶段的响应来决定是否可以继续事务的preCommit操作
>
> 如果响应Yes，则：
>
> ``` java
> 1.发送预提交请求：
> 	协调者向参与者发送PreCommit请求，并进入Prepared阶段。
> 
> 2.事务预提交
> 	参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
> 
> 3.响应反馈
> 	如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。
> ```
>
> 
>
> 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。则有
>
> ```java
> 1.发送中断请求：
> 	协调者向所有参与者发送abort请求。
> 
> 2.中断事务
> 	参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。
> ```

### do commit 

> 协调者根据参与者preCommit阶段的响应来决定是否可以继续事务的doCommit操作。根据响应情况，有下面两种可能	

## 2pc与3pc区别
对于协调者(Coordinator)和参与者(Cohort)都设置了超时机制（在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到cohort的消息则默认失败）。
在2PC的准备阶段和提交阶段之间，插入预提交阶段，使3PC拥有CanCommit、PreCommit、DoCommit三个阶段。
PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。

# 3. 分布式事务：一致性，高并发

调高并发大部分都是牺牲一致性来完成的



# 4. 可靠消息服务

![image-20220715010213559](https://cdn.wuzx.cool/image-20220715010213559.png)

![image-20220715011126055](https://cdn.wuzx.cool/image-20220715011126055.png)

+ 业务执行玩，发布一个事件存入到事件表中（创建状态）
+ 定时任务查询事件表数据然后发送到mq
+ 然后一个消费者接受消息，然后存入到到另外事件表(设为已接收状态)
+ 定时任务处理这个这个事件
