# 1.聊一下Java的集合类

集合的体系，接口

# 3. 集合类是怎么解决高并发中的问题

> 线程非安全的集合类ArrayList、 LinkedList、HashSet 、TreeSet、HashMap、TreeMap实际开发中我们自己用这样的集合，因为我们自己手写的业务代码中，不太涉及到多个线程共享同一个集合问题。
>
> 线程安全的集合 Vector HashTable虽然效率没有JUC中的高性能集合高，单也是可以适用大部分环境

## ConcurrentHashMap

java5.0在juc包中提供了大量支持并发的容器类，采用“锁分段”机制，Concurrentlevel分段级别，默认16，就是有16个段（segment)，每个段默认又有16个哈希表（table），每个又有链表连着。

![image-20220716103439729](https://cdn.wuzx.cool/image-20220716103439729.png)



## ConcurrentHashMap和Hashtable区别

## ConcurrentHashMap线程安全的具体体现方式/底层的具体实现

## 说说copyOnWriteArrayList

> CopyOnWriteArraySet addIfAbsent和 CopyOnWriteArrayList（写入并复制）也是juc里面的，它解决了并发修改异常，每当有写入的时候，就在底层重新复制一个新容器写入，最后把新容器的引用地址赋给旧的容器，在别人写入的时候，其他线程读数据，依然是旧容器的线程。这样是开销很大的，所以不适合频繁写入的操作。适合并发迭代操作多的场景。只能保证数据的最终一致性

# 4.简述一下自定义异常的场景

借助异常机制,我们可以省略很多业务逻辑上的判断处理,直接借助java的异常机制可以简化业务逻辑判断代码的编写

+ 1.当你不想把你的错误直接暴露给前端或者你想让前端从业务角度判断后台的异常，这个时候自定义异常类是你的不二选择
+ 2 虽然JAVA给我们提供了丰富的异常类型,但是在实际的业务上,还有很多情况JAVA提供的异常类型不能准确的表述出我们业务上的含义

# 5.描述一下Object类中常用方法

toString hashCode equals clone finalized wait notify notifyAll 

toString 定义一个对象的字符串表现形式 Object类中定义的规则是 类的全路径名+@+对象的哈希码 重写之后 我们可以自行决定返回的字符串中包含对象的那些属性信息 … 

clone >>>返回一个对象的副本 深克隆 浅克隆 原型模式 重写时实现Cloneable

finalized GC 会调动该方法 自救

# 6.JDK8新特性

- **Lambda****表达式**
- **函数式接口** **函数式编程**
- **方法引用和构造器调用**
- **Stream API**
- **接口中的默认方法和静态方法**
- **新时间日期API**

## 6.1 **接口的默认方法**

> 接口默认是 public abstract
>
> 1.8可以在接口中使用 default 和方法实现，以及static
>
> ``` java
> public interface hello {
> 
> 
>     default  void test() {
>         
>     };
> 
>     static void hello() {
>         
>     }
> }
> ```
>
> 

# 7.**equals()**和==区别。为什么重写equal要重写hashcode

+ 区别

  + == 是运算法，equals 是来自Object中定义的方法
  + == 可以用于基本数据类型和引用数据类型的比较
  + equals 只能用于引用类型
  + == 两端如果是基本数据类型，就是判断值是否相同，equals在重写之后，判断对象属性值是否相同
  + equals如果不重写就是== 

+ 为什么重写equal要重写hashcode

  > + 重写equals自己定义判断两个对象是否相同的条件
  > + 重写hashcode 我们可以自定义hashcode生成规则

# 8. hashMap在jdk8做了哪些优化

## 数据结构

> Jdk7 数组+链表
>
> jdk8 数据+ 链表+ 红黑树
>
> jdk7使用的是头插法，jdk8使用的是尾插法

## hash函数

将hash值的高位(前16位)参与到取模运算中，使得计算结果不确定性增强，降低hash碰撞的概率

## 扩容优化 

扩容以后,1.7对元素进行rehash算法,计算原来每个元素在扩容之后的哈希表中的位置,

1.8借助2倍扩容机制,元素不需要进行重新计算位置

JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算**（****e.hash & oldCap****）**来确定元素是否需要移动

## **为什么**hashmap扩容的时候是两倍

> 

# 9.**解决**hash冲突的方式

> 开放定址法 
>
> 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 
>
> 2再哈希法： 
>
> 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。
>
> 3链地址法
>
> 链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向 链表连接起来
>
> 4建立公共溢出区
>
> 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

# 10.**Tomcat**为什么要重写类加载器

> 类加载器的双亲委派: 应用类加载器->扩展类加载器->引导类加载器	,安全防止重复加载
>
> 无法实现隔离:
>
> + 如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。一个web容器可能要部署两个或者多个应用程序，不同的应用程序，可能会依赖同一个第三方类库的不同版本，因此要保证每一个应用程序的类库都是独立、相互隔离的。部署在同一个web容器中的相同类库的相同版本可以共享，否则，会有重复的类库被加载进JVM, web容器也有自己的类库，不能和应用程序的类库混淆，需要相互隔离
>
> 无法实现热替换：
> + jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。
>
>   打破双亲委派机制(参照JVM中的内容)OSGI是基于Java语言的动态模块化规范，类加载器之间是网状结构，更加灵活，但是也更复杂,JNDI服务，使用线程上线文类加载器，父类加载器去使用子类加载器

# 11.hashmap为什么使用红黑树而不使用其他AVL树

> 普通的AVL树，任何节点的左右子树的绝对值不超过1，当超过1的时候，通过左旋或者右旋来保持平衡，由于旋转比较耗时，所以AVL树适用于插入和删除比较少、查询多得一个情况
>
> 红黑树:相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，用红黑树在某些情况下面只需要改变他的颜色就可以，不需要进行旋转

**Condition** **类和****Object** **类锁方法区别**

1. Condition 类的 awiat 方法和 Object 类的 wait 方法等效 
2. Condition 类的 signal 方法和 Object 类的 notify 方法等效 
3. Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 
4. ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的 

**tryLock****和****Lock****和****lockInterruptibly** **的区别** 

1. tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false 
2. lock 能获得锁就返回 true，不能的话一直等待获得锁 
3. lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常

# 12.Mybatis 一级缓存



# 13.Mybatis二级缓存
