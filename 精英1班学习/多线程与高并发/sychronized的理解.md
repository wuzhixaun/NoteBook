## 一、sychronized的介绍

+ 无论**synchronized**关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
+ 每个对象只有一个锁（**lock**）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
+ 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制
+ **sychronized**是可以重入琐



## 二、sychronized的底层实现

jdk比较早期 重量级的实现 -需要找**os**申请琐

改进：

琐升级的概念:

​	我就是厕所所长

原来是找os 或者内核申请琐，

```
sync(object)
第一次 是不会给Object加锁的，而是markword记录线程的线程ID(偏向锁)
如果有线程争用:升级为 自旋锁->不会进入等待队列，直接等待使用Cpu
10次以后，升级为重量级琐-OS(升级琐)
```

+ 执行时间短（加锁代码），线程数少，用自旋
+ 执行时间长，线程数多，用系统锁



## 三、sychronized优化

同步代码块中的语句越少越好



+ 锁定某对象o，如果o的属性发生变化，不影响琐的使用，但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象
+ 不要使用string作为锁对象，string对象，例如使用s1='hello' s2='hello'其实锁定的是同一个对象

