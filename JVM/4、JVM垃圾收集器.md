# 一、垃圾收集算法

![](https://cdn.wuzx.cool/image-20220807115554485.png)

## 1.1 分代收集理论

根据对象存活的周期，将内存划分几块。一般java堆分为`新生代`和`老年代`，根据各个年代的特点选择合适的垃圾收集算法。

+ 新生代：每次收集都会有大量的对象(近99%)死去，可以选择赋值算法，只需要付出复制少量对象的复制成本就可以完成垃圾收集。
+ 老年代：对象的存活几率很高，而且没有空间对他进行分配担保，所以我们选择`标记-清除`或`标记-整理`算法进行垃圾收集。“标记-清除”或“标记-整理”算法会比复制算法慢10倍以 上。

## 1.2 标记-复制算法

> 为了解决效率问题，`复制`收集算法出现，他将内存分为大小相同的两块。每次使用其中的一块。当这一块内存使用完之后，将还存活的对象复制到另外一块中去，然后再把使用的空间一次清理掉，这样的回收每次都是对内存的一半进行回收

![image-20220807121024185](https://cdn.wuzx.cool/image-20220807121024185.png)

## 1.3 标记-清除算法

> 算法分为`标记`和`清除`阶段。标记存活的对象，统一回收所有未被标记的对象(Hotspot一般都是这样)，当然也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，比较简单，但是会有两个比较明显的问题：
>
> + 效率问题(如果需要标记的对象太多，效率不高。)
> + 空间问题(标记清理之后会产生大量不连续的碎片)

![image-20220807121557978](https://cdn.wuzx.cool/image-20220807121557978.png)

## 1.4 标记-整理算法

> 根据老年代的特点特出的一种垃圾收集算法，标记过程和`标记-清除`算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存

![image-20220807121817439](https://cdn.wuzx.cool/image-20220807121817439.png)

# 二、垃圾收集器

![image-20220807122708670](https://cdn.wuzx.cool/image-20220807122708670.png)

## 2.1 Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)

> Serial(串行)收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个`单线程收集器`了它 的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工 作的时候必须暂停其他所有的工作线程( "Stop The World" )，直到它收集结束。

新生代使用`标记-复制`算法，老年代使用`标记-整理`算法

![image-20220808010951811](https://cdn.wuzx.cool/image-20220808010951811.png)

`Stop The World`带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短 (仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)

### Serial收集器有没有优于其他垃圾收集器的地方呢

> 它简单而高效(与其他收集器的单线程相比)。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。

### Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途:

+ 一种用途是在JDK1.5 以及以前的版本中与Parallel Scavenge收集器搭配使用，
+ 另一种用途是作为CMS收集器的后备方案

## 2.2 Parallel Scavenge收集器(-XX:+UseParallelGC -XX:+UseParallelOldGC)

> `Parallel收集器`就是`Serial`的多线程版本,除了使用多线程进行垃圾收集之外，其余行为(控制参数、收集算 法、回收策略等等)和Serial收集器类似
>
> 默认的收集线程数与CPU核数相同，可以使用参数`-XX:ParallelGCThreads`指定收集线程数，但是一般不推荐修改。

**Parallel Scavenge收集器关注点是吞吐量(高效率的利用CPU)。CMS等垃圾收集器的关注点更多的是用户线程的停 顿时间(提高用户体验)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值**

`新生代采用复制算法，老年代采用标记-整理算法。`

![image-20220808011824421](https://cdn.wuzx.cool/image-20220808011824421.png)

> Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集 器)。

## 2.3 ParNew收集器（-XX:+UseParNewGC）

> ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用
>
> **新生代采用复制算法，老年代采用标记-整理算法。**

![image-20220808012641604](https://cdn.wuzx.cool/image-20220808012641604.png)

## 2.4 CMS收集器(-XX:+UseConcMarkSweepGC)老年代

> CMS(Concurrent Mark Sweep)收集器是一种以获取最短停顿时间为目标的垃圾收集器。非常符合注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器。第一次实现了让垃圾收集线程与用户线程基本上同时工作。

CMS收集器是一种 `标记-清除`实现的，运作步骤如下

+ `初始标记`：暂停所有线程(STW),记录下`GC ROOT`直接能引用的对象，速度很快。

+ `并发标记`：并发标记阶段就是从`GC ROOT`的直接关联对象开始遍历开始遍历整个对象图的过程。这个过程比较耗费时间，但是不需要停顿用户线程，可以和垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变

+ `重新标记`：重新标记主要是为了修正`并发标记`过程中因为用户程序继续运行而导致标记变动的部分标记记录，这个阶段会稍微比初始标记的时间长，但是远远比并发标记阶段的时间短。主要用到`三色标记`里面的`增量更新`算法

+ `并发清理`：开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新的对象产生，那么会被标记成黑色不做任何处理

+ `并发充值`：重置本次GC过程中的标记数据。

  ![](https://cdn.wuzx.cool/image-20220808014030299.png)

### 主要优点：

+ 并发收集
+ 低停顿

### 缺点：

+ 对CPU敏感，用户线程和GC线程会抢占资源
+ 无法处理浮动垃圾，只能等到下一次GC在清理
+ 使用的是`标记-清除`算法，会产生大量的空间碎片，可以通过参数`-XX:+UseCMSCompactAtFullCollection`让JVM执行垃圾收集后进行整理
+ 执行过程中，存在不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况。`concurrent mode failure`:当老年代的内存不足。然后就会**stop the world，用serial old垃圾收集器来回收**

### CMS的相关核心参数

> 1. -XX:+UseConcMarkSweepGC:启用cms
> 2. -XX:ConcGCThreads:并发的GC线程数
> 3. -XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩整理(减少碎片)
> 4. -XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 次
> 5. **-XX:CMSInitiatingOccupancyFraction**: 当老年代使用达到该比例时会触发FullGC(默认是92，这是百分比) 
> 6. **-XX:+UseCMSInitiatingOccupancyOnly**:只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整
> 7. **-XX:+CMSScavengeBeforeRemar**k:在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段
> 8. -XX:+CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW
> 9. -XX:+CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW;

## 2.5 G1（-XX:+UseG1GC）

>  G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC 停顿时间要求的同时,还具备高吞吐量性能特征.

![image-20220808015646310](https://cdn.wuzx.cool/image-20220808015646310.png)

> G1将Java堆划分为多个大小相等的独立区域`Region`,JVM最多可以有2048个Region
>
> 一般Region大小等于堆内存大小/2048,比如堆大小为4096M，则Region大小为2M.也可以使用`-XX:G1HeapRegionSize`手动指定Region
>
> G1保留了老年代，年轻代的概率，但是不是物理上的，而是逻辑上的，它们可以是不联系的Region的集合
>
> 默认年轻代占堆内存大小的5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存。对应大概100个region。可以通过`-XX:G1NewSizePercent`设置新生代初始占比，在系统运行时，JVM会不停的给年轻代增加更多的Region，但是最多不会超过60%,可以通过`-XX:G1MaxNewSizePercent`调整。年轻代中的Eden和s0和s1默认是8:1:1。假设年轻代现在有1000个region，eden区对应800个，s0对应100 个，s1对应100个。
>
> 一个Region可能之前是年轻代，进行垃圾回收之后，可能变回老年代。Region的区域功能是动态变化的
>
> G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理。G1有专门分配 大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。大对象的判定规则就是一个大对象如果超过的Region的50%,就会被放入`Humongous`中,如果对象实在太大，可以横跨多个Region存放。
>
> Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开 销
>
> Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收

### G1收集器步骤

+ `初始标记(initial mark，STW)`：暂停所有的线程，记录`GC ROOT`直接引用对象，速度很快

+ `并发标记(Concurrent making)`:和CMS并发标记一样，拿到初始标记的直接引用对象，然后遍历整个对象的图的过程，用户线程和GC线程并发执行。这个时候会出现标记过得对象在用户线程执行后出现状态问题

+ `最终标记(Remark STW)`:同CMS重新标记，就是为了修正并发标记过程中，标记过的对象状态问题

+ `筛选回收(Clean STW)`:筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期

  望的GC停顿时间(可以用JVM参数` -XX:MaxGCPauseMillis`指定)来制定回收计划。

  > 回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片

![image-20220808021652799](https://cdn.wuzx.cool/image-20220808021652799.png)

> **G1收集器在后台维护了一个优先列表**，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字 Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回 收时间有限情况下，G1当然会优先选择后面这个Region回收

### 特点

+ 并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式 让java程序继续执行。
+ 分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
+ 空间整合:与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器;从局部 上来看是基于“复制”算法实现的。
+ 可预测的停顿:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了 追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数"- XX:MaxGCPauseMillis"指定)内完成垃圾收集。

### G1垃圾收集分类

#### YoungGC 

> YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC

####  MixedGC

> 不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的 Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做 MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够 的空region能够承载拷贝对象就会触发一次Full GC

#### Full GC 

> 停止系统程序，然后采用`单线程`进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)

### G1收集器参数设置

> -XX:+UseG1GC:使用G1收集器
>  -XX:ParallelGCThreads:指定GC工作的线程数量 -XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区 -XX:MaxGCPauseMillis:目标暂停时间(默认200ms)
>  -XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%)
>  -XX:G1MaxNewSizePercent:新生代内存最大空间 -XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个
>
> 年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代 -XX:MaxTenuringThreshold:最大年龄阈值(默认15) -XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合
>
> 收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能 就要触发MixedGC了
>
> -XX:G1MixedGCLiveThresholdPercent(默认85%) region中的存活对象低于这个值时才会回收该region，如果超过这 个值，存活对象过多，回收的的意义不大。
>
> -XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一 会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。
>
> -XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都 是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清 理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立 即停止混合回收，意味着本次混合回收就结束了。
