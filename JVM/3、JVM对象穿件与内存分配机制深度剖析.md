# 一、对象的创建

![image-20220805021120332](https://cdn.wuzx.cool/image-20220805021120332.png)

## 1.1 类加载检查

> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程

## 1.2 分配内存

> 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从`Java堆中划分出来`

### 划分内存的方法:

+ 指针碰撞

  > 默认采用的是指针碰撞的方式。如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离
  >
  > ![image-20220805021456105](https://cdn.wuzx.cool/image-20220805021456105.png)

+ 空闲列表

  > 如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
  >
  > ![image-20220805021531267](https://cdn.wuzx.cool/image-20220805021531267.png)

### 如何解决多个对象并发占用空间的问题？

多个线程new的对象都要分配内存，不管内存分配使用的是哪种方式，指针碰撞也好，空闲列表也好，这些对象都要去争抢这块内存

+ CAS（compare and swap）

  > CAS可以理解为多个线程同时去争抢一个快内存，抢到了的就使用，没抢到的就重试去抢下一块内存。
  >
  > 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理

+ 本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）

  > TLAB是为了避免多线程争抢内存，在每个线程初始化的时候，就在堆空间中为线程分配一块专属的内存。自己线程的对象就往自己专属的那块内存存放就可以了。这样多个线程之间就不会去哄抢同一块内存了。jdk8默认使用的就是TLAB的方式分配内存。
  >
  > 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过-XX:+UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启-XX:+UseTLAB)，­-XX:TLABSize 指定TLAB大小

## 1.3 初始化

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)， 如果使用TLAB，这一工作过程也 可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问 到这些字段的数据类型所对应的零值

## 1.4 设置对象头

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:`对象头(Header)`、` 实例数据(Instance Data)` 和`对齐填充(Padding)`

### 对象头

![image-20220805022235598](https://cdn.wuzx.cool/image-20220805022235598.png)

`Klass Pointer类型指针`:这个就是一个new对象，对象存储在堆中，然后类元数据是在方法区，这个指针就是对象指向方法区的类元数据信息

## 1.5.执行<init>方法

> 执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值(注意，这与上面的赋零值不同，这是由程序员赋的值)，和执行构造方法

## 1.6 什么是java对象的指针压缩?
 1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩 2.jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针 3.启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­UseCompressedOops

### 为什么要进行指针压缩? 

+ 1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力
+ 2.为了减少64位平台下内存的消耗，启用指针压缩功能
+  3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm 只用32位地址就可以支持更大的内存配置(小于等于32G) 
+ 4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间 
+ 5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内 存不要大于32G为好

## 二、对象内存分配

![对象内存分配](https://cdn.wuzx.cool/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png)

## 2.1 对象栈上分配(栈上分配依赖于逃逸分析和标量替换)

> JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的 内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力



`对象逃逸分析:`就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参
数传递到其他地方中

``` java
public class Test {

    public User test1() {
        User user = new User();
        user.setId(1);
        user.setName("张三");
        return user;
    }

    public void test2() {
        User user = new User();
        user.setId(2);
        user.setName("李四");
    }
}
```

很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结 束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内 存一起被回收掉

`标量替换`:通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认 开启

## 2.2 对象在Eden区分配

大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC

+ `Minor GC/Young GC`:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
+ `Major GC/Full GC`:一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢 10倍以上。

### Eden与Survivor区默认8:1:1

> 大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活 的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回 收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所 以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可，
>
> JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变 化可以设置参数-XX:-UseAdaptiveSizePolicy

## 2.3 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象(比如:字符串、数组)。JVM参数 -XX:PretenureSizeThreshold 可以设置大 对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下 有效。比如设置JVM参数:-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代

### 为什么要这样呢?

> 为了避免为大对象分配内存时的复制操作而降低效率。

## 2.4 长期存活的对象将进入老年代

> 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在 长期存活的对象将进入老年代老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄(Age)计数器。
>
> 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同)，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `XX:MaxTenuringThreshold` 来设置

## 2.5 对象动态年龄判断

> 一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了。对象动态年龄判断机制一般是在minor gc之后触发的。

## 2.6 老年代空间分配担保机制

![image-20220805024054124](https://cdn.wuzx.cool/image-20220805024054124.png)

> 年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间
>
> 如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)
>
> 就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了
>
> 如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。
>
> 如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，
>
> 如果回收完还是没有足够空间存放新的对象就会发生"OOM"当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，fullgc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”
