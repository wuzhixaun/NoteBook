# 1、索引的优点

+ 大大减少服务器需要扫描的数据量
+ 帮助服务器避免排序和临时表
+ 将随机IO变成顺序IO



# 2、索引的用处

+ 快速查找匹配WHERE的行
+ 从consideration中消除行，如果可以在多个索引只见那进行选择，mysql通常会使用找到最少行的索引
+ 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行
+ 当有表链接的时候，从其他表检索行数据
+ 查找特定索引列的min或max值
+ 如果排序或分组时在可用索引的左前缀上完成的，则对表进行排序和分组
+ 在某些情况下，可以优化查询以检索值而无需查询数据行



# 3、索引的分类

+ 主键索引
+ 唯一索引
+ 普通索引
+ 全文索引
+ 组合索引

> 数据库会给默认给唯一键创建索引



# 4、 面试技术名词

+ 回表: 回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树。

![img](https://img2018.cnblogs.com/blog/1442837/201905/1442837-20190529175036406-107640637.png)

+ 覆盖索引: 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖

> 注：遇到以下情况，执行计划不会选择覆盖查询
> 1.select选择的字段中含有不在索引中的字段 ，即索引没有覆盖全部的列。
> 2.where条件中不能含有对索引进行like的操作。

+ 最左匹配：**最****左****匹配**原则也叫最**左**前缀原则，是 **MySQL** 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（>、<、between、like）就会停止匹配
+ 索引下推：

> - 在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立**联合索引（name，age）**。
> - 假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：
>
> ``` sql
> SELECT * from user where  name like '陈%'
> ```
>
> + 根据 "最佳左前缀" 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高
> + **问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户**，此时的sql语句如下：
>
> ```
> 　　SELECT * from user where  name like '陈%' and age=20
> ```
>
> - 

- 5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：

  > ![img](https://gitee.com/chenjiabing666/Blog-file/raw/master/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/1.png)

- 会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要**回表两次**。

# 5、索引采用的数据结构

+ 哈希表
+ B+ 数

